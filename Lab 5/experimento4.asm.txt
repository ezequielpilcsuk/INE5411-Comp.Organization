.data
_v: .word 9,8,7,6,5,4,3,2,1,-1
_n: .word 10

.text
.globl main

main:
  la   $a0,_v  
  lw   $a1,_n 
  addi $s3, $zero, 2019
  jal sort             # MARCA 3
  addi $t1, $s3, 1     # MARCA 4
  li  $v0,10           # MARCA 5: syscall code = exit
  syscall
  
sort:
  addi $sp,$sp,-16 #-20
  sw   $ra,12($sp) #16
  sw   $s3,8($sp) # save $s3 on stack
 	#sw $s2, 8($sp)# save $s2 on stack
  sw   $s1,4($sp)  
  sw   $s0,0($sp)  
  
	#move $s2, $a0 # copy parameter $a0 into $s2 (save $a0)
  move $s3, $a1 # copy parameter $a1 into $s3 (save $a1)
  move $s0,$zero   # MARCA 0: inicializa√ß√£o da vari√°vel i

# in√≠cio do corpo do la√ßo externo
for1tst:  

  nop # MARCA 1
  slt $t0, $s0,$s3 #reg$t0=0if$s0ä$s3(iän)
  beq  $t0,$zero,exit1  
  addi $s1,$s0,-1  

# inicio do corpo do la√ßo interno
for2tst:
  slti $t0,$s1,0  
  bne  $t0,$zero,exit2 
  sll  $t1,$s1,2   
  add  $t2,$a0,$t1 #add $t2, $s2, $t1  / reg $t2 = v + (j * 4)
  lw   $t3,0($t2)
  lw   $t4,4($t2)
  slt  $t0,$t4,$t3
  beq  $t0,$zero,exit2

  	#move $a0, $s2 # 1st parameter of swap is v (old $a0)
  move $a1, $s1 # 2nd parameter of swap is j
  	#Pass parameters and call
  nop # MARCA 2 
  jal  swap 	
  addi $s1,$s1,-1
  j    for2tst
# fim do corpo do la√ßo interno
exit2:
  addi $s0,$s0,1
  j    for1tst
# fim do corpo do la√ßo externo
exit1:
  lw   $s0,0($sp)  
  lw   $s1,4($sp)
  	#lw $s2, 8($sp)# restore $s2 from stack
  lw   $s3,8($sp) # restore $s3 from stack
  lw   $ra,12($sp) #16
  addi $sp,$sp,16 #20
  jr   $ra
# implementa√ß√£o da procedure swap
swap:
  sll  $t1,$a1,2   # reg $t1=k*4
  add  $t1,$a0,$t1 # reg $t1=v+(k*4)
  lw   $t0,0($t1)  # reg $t0 (temp)  =v[k]
  lw   $t2,4($t1)  # reg $t2 = v[k+1]
  sw   $t2,0($t1)  # v[k] = reg $t2
  sw   $t0,4($t1)  # v[k+1] = reg $t0 temp
  jr   $ra         # retorna para a rotina chamadora
  
